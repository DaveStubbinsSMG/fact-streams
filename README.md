# Fact-streams

Fact-streams is a TypeScript library that makes it very easy to build applications using the event sourcing paradigm in a [Node.js](https://nodejs.org) and [MongoDB](https://www.mongodb.org/) stack. It provides an alternative to [mongoose](https://mongoosejs.com/) and the CRUD paradigm.

## What is event sourcing?

At its core, event sourcing involves modeling the state of an application as a series of immutable events (also called facts), each representing a specific change or action that has occurred within the system. These events are stored in an event log, which serves as the single source of truth for the application's historical data. You can then replay the sequence of events to recreate the current state af an individual entity or the entire system. This is a powerful feature for debugging, auditing, and rebuilding system state.

You get several benefits when you use event sourcing:
- **Flexibility and evolution**: You can easily evolve the system's data model and business logic over time. You can add new event types, update existing ones, and introduce new behaviour without losing historical data and without implementing complex migrations.
- **Performance, scalability and simplicity**: You can optimise read and write operations independently. You can even create multiple read views per store, that are optimised for different query patterns. Your queries become faster to run but also simpler to write and maintain.
- **Business insights**: You capture not just the final state, but also the sequence of events leading to that state. This information allows you to retrospectively run reports that are impossible to build in a CRUD system.
- **Complete audit trail**: By maintaining a full historical record of all events that have occurred you can track how data evolved over time and who initiated each change.
- **Temporal querying**: You can replay events to recreate the system's state at any specific moment in time. This capability is valuable for debugging, troubleshooting, and analyzing past states.

You can learn more about event-sourcing in this [talk](https://www.youtube.com/watch?v=8JKjvY4etTY) by Greg Young, which is an excellent introduction to key concepts and it has been the inspiration for building *fact-streams*. This [talk](https://www.youtube.com/watch?v=ck7t592bvBg) by Martin Fowler and this [guide](https://www.eventstore.com/event-sourcing) are also very good sources of information.

## Nomenclature & key decisions

The term *event* and *event-driven* has multiple meanings in software architecture and this often creates a lot confusion. *Fact-stream* deliberately uses the term **fact** to model the events to make it clear that it is not related to similarly named technologies like event-buses, microservices etc.

*Fact-stream* is suitable for application that use the monolith architecture. It has been build to allow horizontal scaling nevertheless.

## Basic concepts in fact-streams

A **fact** represents an action or an event that took place in the domain. They are the single source of truth. The current state is derived from the facts. They are immutable and represent the business facts. Each fact has a `type` property, which is usually a verb in past tense, and signify what action this fact represents. It also has a `data` property, which contains information about the action.

A **fact stream** is the series of facts about a specific object. For example each user in your system would be a separate stream.

A **fact store** provides a mechanism to append and read facts from individual streams. It is usually a single MongoDB collection. As example would be a `User` collection.

A **view** is some aspect of the current state of the system. It is generated by replaying the facts in the order they occurred. Views can be *transient*, which mean they are generated on-the-fly when we query the data. They can also be *persistent*, which means that every time we append an event fact-streams will replay the facts and store the view's state in another MongoDB collection, for more efficient queries.

A **reducer** is a function that takes as input the current state of the application and a single fact, and returns the new state by applying the fact. Reducers are the core mechanism that replay the facts and therefore build the views.

## Basic concepts with an example

Let's go through an example, to see how *fact-streams* can help you create a model for an entity in your application. We will model an `invoice` entity.

### Connect to a MongoDB database

First, we need to connect to our database.

```typescript
import { connect } from 'fact-stream';

const db = await connect({
  uri: 'mongodb://localhost:27017/',
  dbName: 'myExample',
});
```

It is recommended, but not required, to create a *single* connection instance for your application and use it to create all the fact stores. It is safe to use this connection outside *fact-stream* if you want to run queries using the MongoDB driver directly.

### Define your fact types

We need to think what facts we want to track over time for each `invoice` in our system and create the corresponding types. For each fact we need to specify a `type` which acts like an identifier and also decide what is the data we want to capture. Noetice that `data` is not always required.

```typescript
import { Fact } from 'fact-stream';

// As meta-data, we want to track who was the user that initiated a change and what was their IP
interface Who {
  username: string;
  ip: string;
}

// One type per fact
type Created = Fact<'created', { recipient: string; dueDate: Date; }, Who>;
type ItemAdded = Fact<'itemAdded', { id: number; name: string; quantity: number, price: number; }, Who>;
type ItemRemoved = Fact<'itemRemoved', { id: number; }, Who>;
type Sent = Fact<'sent', null, Who>;

// A union type that represents any valid fact for this entity
type InvoiceFact = Created | ItemAdded | ItemRemoved | Sent;
```

When working with JavaScript (as opposed to TypeScript) you do not need to create types obviously, however it is critical to think about what facts you want to track.

### Create a fact-store instance

```typescript
const store = await db.createFactStore<InventoryFact>({
  name: 'invoiceFacts',
});
```

A fact store provides a mechanism to append and read facts from individual streams. It is recommended, but not required, that you create only one instance per entity.

### Create commands, that append facts in the DB

```typescript
import { createFact, NEW } from 'fact-stream';

function create = (who: Who, recipient: string, dueDate: Date) {
  const fact = createFact<Created>(NEW, 'created', { recipient, dueDate }, who);
  return store.append(fact);
}

// Or in one-liners if you prefer the code style
const addItem = (who: Who, invoiceId: number, itemId: number, name: string, quantity:number, price:number) => store.append(createFact<ItemAdded>(invoiceId, 'itemAdded', { itemId, name, quantity, price }, who));
const removeItem = (who: Who, invoiceId: number, itemId: number) => store.append(createFact<ItemRemoved>(invoiceId, 'itemRemoved', { itemId }, who));
const send = (who: Who, invoiceId: number) => store.append(createFact<Sent>(invoiceId, 'sent', null, who));
```

This is all we need to write data. Notice how we created *command* functions that have names that make sense in the business context.

### Create one or more reducer functions

```typescript
interface Invoice {
  recipient: string;
  dueDate: Date;
  items: {
    name: string;
    quantity: number;
    price: number;
  }[];
  total: number;
  sentBy: string;
}

// TODO: recuder function
```
### Create a transient view

Transient views read the facts from the fact-store and replay them on-the-fly, using one reducer function.

```typescript
const getInvoice = store.createTransientView(invoiceReducer, null);

// We can now call:
const invoice = await getInvoice(invoiceId);
```

### Create a persistent view

Persistent views are using a MongoDB collection to save the latest state of each entity. They are useful when you want to query across many instances of your entity.

```typescript
const invoiceCollection = store.createPersistentView({
  collectionName: 'invoices',
  invoiceReducer,
});

// We can now call:
const invoices = await invoiceCollection.find({ total: { $gte: 1000 }});
```

### Export your model
```typescript
export default {
  create,
  addItem,
  removeItem,
  send,
  getInvoice,
  invocieCollection,
}
```
